## 시나리오 부하테스트

### 시나리오 종류
#### 1.유저의 포인트 조회 및 충전/사용

조회와 충전/사용  즉 데이터의 변경과 조회가 자주일어나기 떄문에 index를 걸지 않았다.
오직 DB와 Spring app만 사용하기에 DB와 Spring app의 리소스 지표만 보았을 때,
Spring app의 Cpu의 부하가 너무 심하게 걸리지만 , DB의 CPU는 부하를 잘버티는 것을 보고,
1번 시나리오에서는 Spring app의 톰캣의 쓰레드 갯수를 올려 CPU의 부하를 줄이는 방식으로 개선하면 좋을 것 같았다.

#### 2. 콘서트와 콘서트 옵션 조회 및 대기열 등록

콘서트와 콘서트 옵션 조회에는 redis의 캐시를 사용하였고, 대기열 등록도 redis를 사용해서 해결했다.
2번 시나리오에 부하를 주었더니 역시 Spring app의 CPU의 부하가 정말 심했지만, DB와 Redis의 리소스에는 부하가 적게걸렸다
이를 보았을 때 우선 만약 콘서트와 콘서트 옵션에 cache를 사용하지 않았다면, 같은 정보를 계속 DB에서 조회했을 것으로 생각되기 때문에
DB에 쓸대없는 부하들이 같이 걸릴 것이라고 생각했고, redis로 대기열을 처리했고, 캐시도 넣었기에 redis에 부하가 많이 걸릴 것으로 예상했는데
생각보다 많은 데이터가 요청이 들어가고 저장이되는데도 레디스의 부하가 거의 안걸렸다.. 이래서 redis로 캐시로 쓰고 대기열 구현을 한 것으로 느꼈다..
만약 대기열을 redis가 아닌 inmemory DB를 사용했었더라면, DB에 정말 많은 부하가 걸렸을 것 같다.


#### 3. 대기열 등록 후 콘서트 예약가능일 조회

마찬가지로 대기열은 Redis를 사용했고, 콘서트 예약일 가능일은 DB를 사용했는데
이 부분에서는 redis와 DB모두 부하를 잘 버텨 낮은 리소스를 사용헀다.
이 부분도 Spring app의 app의 톰캣의 쓰레드 갯수를 올려 CPU의 부하를 줄이는 방식으로 개선하면 좋을 것 같았다.


#### 4. 대기열 등록 후  예약가능한 좌석을 조회하고, 좌석을 예약하는 시나리오(대기열 활성화했다고 가정)

이 부분은 그냥 테스트 병목현상까지 가지도 못하고 Docker가 뻗었다.. 이 부분도 무조건 Spring app의 app의 톰캣의 쓰레드 갯수를 올려 CPU의 부하를 줄이는 방식으로 개선하면 좋을 것 같았다.
하지만 좌석 예약 시나리오에서 DB에 적절한 Lock을 걸어서 동시성 문제를 해결하는 것을 확인 할  수 있었다. 만약 DB의 Lock을 빼고 실행 할 경우 insert부분에서는 unique 제약조건으로 걸러지지만,
예약한 후 결제되지 않고 userID가 지워진 좌석은 update를 통해 좌석 예약이 이루어지는데 이 부분에서 계속 업데이트 되는 것이 보았다.

하지만
  server:
    tomcat:
      threads:
        max: 250  # 톰캣 스레드 풀
이렇게 톰캣 스레드 풀을 늘리면 도커의 CPU가 힘들어하긴 하지만 그래도 조금 더 부하를 주어도 뻗지않는 것을 확인 할 수 있었다.

#### 5. 대기열 등록 후  좌석을 예약한 사람은 예매 후 결제 및 예약을 하는 시나리오(대기열 활성화했다고 가정)

4번과 마찬가지로 Spring app의 app의 톰캣의 쓰레드 갯수를 올려 CPU의 부하를 줄이는 방식으로 개선하면 좋을 것 같았다. 또한 
만약 강제로 트랜잭션 안에서 쓰레드의 sleep()을 걸었을 때 한두명이아니라 부하를 걸다보니깐 정말 오래걸리는 것을 테스트 했다
트랜잭션을 정말 최소단위로 간결하게 짜라는 것에 대한 의미를 알 수 있었다. 또한 부가로직과 메인로직의 구별없이 테스트 했을 때도
데이터의 정합성이 깨지는 것을 확인할 수 있어서 Kafka를 사용하여 부하도 분산시키고, 부가로직을 통해 데이터의 정합성도 맞춘것이 좋았던 것 같다.

하지만
  server:
    tomcat:
      threads:
        max: 250  # 톰캣 스레드 풀

이렇게 톰캣 스레드 풀을 늘리면 도커의 CPU가 힘들어하긴 하지만 그래도 조금 더 부하를 주어도 뻗지않는 것을 확인 할 수 있었다.